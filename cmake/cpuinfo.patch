diff --git src/arm/linux/chipset.c src/arm/linux/chipset.c
index 35058d9..4edb343 100644
--- src/arm/linux/chipset.c
+++ src/arm/linux/chipset.c
@@ -1011,12 +1011,59 @@ write_chipset:
 	return true;
 }
 
+/**
+ * Tries to match /BCM\d{4}$/ signature for Broadcom BCM chipsets.
+ * If match successful, extracts model information into \p chipset argument.
+ *
+ * @param start - start of the /proc/cpuinfo Hardware string to match.
+ * @param end - end of the /proc/cpuinfo Hardware string to match.
+ * @param[out] chipset - location where chipset information will be stored upon a successful match.
+ *
+ * @returns true if signature matched, false otherwise.
+ */
+static bool match_bcm(
+	const char* start, const char* end,
+	struct cpuinfo_arm_chipset chipset[restrict static 1])
+{
+	/* Expect exactly 7 symbols: "BCM" (3 symbols) + 4-digit model number */
+	if (start + 7 != end) {
+		return false;
+	}
+
+	/* Check that the string starts with "BCM".
+	 * The first three characters are loaded and compared as a 24-bit little endian word.
+	 */
+	const uint32_t expected_bcm = load_u24le(start);
+	if (expected_bcm != UINT32_C(0x004D4342) /* "MCB" = reverse("BCM") */) {
+		return false;
+	}
+
+	/* Validate and parse 4-digit model number */
+	uint32_t model = 0;
+	for (uint32_t i = 3; i < 7; i++) {
+		const uint32_t digit = (uint32_t) (uint8_t) start[i] - '0';
+		if (digit >= 10) {
+			/* Not really a digit */
+			return false;
+		}
+		model = model * 10 + digit;
+	}
+
+	/* Return parsed chipset. */
+	*chipset = (struct cpuinfo_arm_chipset) {
+		.vendor = cpuinfo_arm_chipset_vendor_broadcom,
+		.series = cpuinfo_arm_chipset_series_broadcom_bcm,
+		.model = model,
+	};
+	return true;
+}
+
 /**
  * Tries to match /OMAP\d{4}$/ signature for Texas Instruments OMAP chipsets.
  * If match successful, extracts model information into \p chipset argument.
  *
  * @param start - start of the /proc/cpuinfo Hardware string to match.
- * @param end - end of the /proc/cpuinfo Hardaware string to match.
+ * @param end - end of the /proc/cpuinfo Hardware string to match.
  * @param[out] chipset - location where chipset information will be stored upon a successful match.
  *
  * @returns true if signature matched, false otherwise.
@@ -2328,6 +2375,14 @@ struct cpuinfo_arm_chipset cpuinfo_arm_linux_decode_chipset_from_proc_cpuinfo_ha
 			return chipset;
 		}
 
+		/* Check Broadcom BCM signature */
+		if (match_bcm(hardware, hardware_end, &chipset)) {
+			cpuinfo_log_debug(
+				"matched Broadcom BCM signature in /proc/cpuinfo Hardware string \"%.*s\"",
+				(int) hardware_length, hardware);
+			return chipset;
+		}
+
 		#if CPUINFO_ARCH_ARM
 			/* Check Texas Instruments OMAP signature */
 			if (match_omap(hardware, hardware_end, &chipset)) {
diff --git src/arm/linux/init.c src/arm/linux/init.c
index 6272abf..a52f74f 100644
--- src/arm/linux/init.c
+++ src/arm/linux/init.c
@@ -228,10 +228,8 @@ void cpuinfo_arm_linux_init(void) {
 	const struct cpuinfo_arm_chipset chipset =
 		cpuinfo_arm_android_decode_chipset(&android_properties, valid_processors, 0);
 #else
-	const struct cpuinfo_arm_chipset chipset = {
-		.vendor = cpuinfo_arm_chipset_vendor_unknown,
-		.series = cpuinfo_arm_chipset_series_unknown,
-	};
+	const struct cpuinfo_arm_chipset chipset =
+		cpuinfo_arm_linux_decode_chipset(proc_cpuinfo_hardware, valid_processors, 0);
 #endif
 
 	#if CPUINFO_ARCH_ARM
diff --git test/get-current.cc test/get-current.cc
index f410b12..96b11dc 100644
--- test/get-current.cc
+++ test/get-current.cc
@@ -36,3 +36,9 @@ TEST(CURRENT_UARCH_INDEX, within_bounds) {
 
 	ASSERT_LT(cpuinfo_get_current_uarch_index(), cpuinfo_get_uarchs_count());
 }
+
+TEST(CURRENT_UARCH_INDEX_WITH_DEFAULT, within_bounds) {
+	ASSERT_TRUE(cpuinfo_initialize());
+
+	ASSERT_LE(cpuinfo_get_current_uarch_index_with_default(cpuinfo_get_uarchs_count()), cpuinfo_get_uarchs_count());
+}
